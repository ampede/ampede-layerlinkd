/* Automatically generated by Ragel from "/Users/bizman/Ampede/PDFLexer-RagelImp.rli".
 *
 * Parts of this file are copied from Ragel source covered by the GNU
 * GPL. As a special exception, you may use the parts of this file copied
 * from Ragel source without restriction. The remainder is derived from
 * "/Users/bizman/Ampede/PDFLexer-RagelImp.rli" and inherits the copyright status of that file.
 */

#line 1 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
//
//  PDFLexer-RagelImp.rli
//  LayerLink
//
//  Created by Eric Ocean on Thu Jul 15 2004.
//  Copyright (c) 2004 Eric Daniel Ocean. All rights reserved.
//

#import "PDFLexer.h"
#import "PDFToken.h"
#import "PDFBoolean.h"
// #import "PDFObjectRef.h"


#define IDENT_BUFLEN 256

#line 27 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
static int PDFParsingMachine_start = 0;

int PDFParsingMachine_init( struct PDFParsingMachine *fsm )
{
	fsm->curs = PDFParsingMachine_start;
#line 67 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
{
		fsm->nullByte = 0;
	}
#line 37 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
	if ( fsm->curs >= 4 )
		return 1;
	return 0;
}

int PDFParsingMachine_execute( struct PDFParsingMachine *fsm, unsigned char *_data, int _len )
{
	unsigned char *_p = _data-1;
	unsigned char *_pe = _data+_len;
	int _cs = fsm->curs;
	fsm->curs = -1;

	if ( ++_p == _pe )
		goto out;
	switch ( _cs ) {
case 0:
	switch( (*_p) ) {
		case 43u: goto tr4;
		case 45u: goto tr4;
		case 46u: goto tr5;
	}
	if ( 48u <= (*_p) && (*_p) <= 57u )
		goto tr6;
	goto st1;
st1:
	if ( ++_p == _pe )
		goto out1;
case 1:
	goto st1;
tr4:
#line 71 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		fsm->numChars = [[NSMutableData alloc] initWithCapacity:10];
	}
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st2;
#line 77 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
st2:
	if ( ++_p == _pe )
		goto out2;
case 2:
	if ( (*_p) == 46u )
		goto tr3;
	if ( 48u <= (*_p) && (*_p) <= 57u )
		goto tr2;
	goto st1;
tr3:
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st3;
tr5:
#line 71 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		fsm->numChars = [[NSMutableData alloc] initWithCapacity:10];
	}
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st3;
#line 103 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
st3:
	if ( ++_p == _pe )
		goto out3;
case 3:
	if ( 48u <= (*_p) && (*_p) <= 57u )
		goto tr0;
	goto st1;
tr0:
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st4;
#line 117 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
st4:
	if ( ++_p == _pe )
		goto out4;
case 4:
	if ( 48u <= (*_p) && (*_p) <= 57u )
		goto tr0;
	goto st1;
tr2:
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st5;
tr6:
#line 71 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		fsm->numChars = [[NSMutableData alloc] initWithCapacity:10];
	}
#line 75 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&(*_p) length:1];
	}
	goto st5;
#line 141 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
st5:
	if ( ++_p == _pe )
		goto out5;
case 5:
	if ( (*_p) == 46u )
		goto tr0;
	if ( 48u <= (*_p) && (*_p) <= 57u )
		goto tr2;
	goto st1;
	}
	out1: _cs = 1; goto out;
	out2: _cs = 2; goto out;
	out3: _cs = 3; goto out;
	out4: _cs = 4; goto out;
	out5: _cs = 5; goto out;

out:
	fsm->curs = _cs;
	if ( _cs == 1 )
		return -1;
	if ( _cs >= 4 )
		return 1;
	return 0;
}

int PDFParsingMachine_finish( struct PDFParsingMachine *fsm )
{
	int _cs = fsm->curs;
	fsm->curs = -1;
	switch ( _cs ) {
	case 4: 
#line 79 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&fsm->nullByte length:1];
		[fsm->self addToken:
							[NSDecimalNumber decimalNumberWithString:
													[NSString
														stringWithCString:(const char *)[fsm->numChars bytes]
														length:[fsm->numChars length]]]];
		[fsm->numChars release]; fsm->numChars = nil;
	}
	break;
	case 5: 
#line 79 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"
	{
		[fsm->numChars appendBytes:&fsm->nullByte length:1];
		[fsm->self addToken:
							[NSDecimalNumber decimalNumberWithString:
													[NSString
														stringWithCString:(const char *)[fsm->numChars bytes]
														length:[fsm->numChars length]]]];
		[fsm->numChars release]; fsm->numChars = nil;
	}
	break;
#line 196 "/Users/bizman/Ampede/PDFLexer-RagelImp.m"
	}

	fsm->curs = _cs;
	if ( fsm->curs == 1 )
		return -1;
	if ( fsm->curs >= 4 )
		return 1;
	return 0;
}

#line 482 "/Users/bizman/Ampede/PDFLexer-RagelImp.rli"

